
// SPDX-License-Identifier: MIT

#Область ПрограммныйИнтерфейс
// Возвращает объект процессора распознавания по переданному регулярному выражению (выбрасывает исключения)
//
// Параметры:
//  Шаблон	 - Строка	 - регулярное выражение
// 
// Возвращаемое значение:
//  Структура - объект ответа:
//  * Шаблон - Массив - токены регулярного выражения,
//  * Орграф - Массив - НКА регулярного выражения
//
Функция ПроцессорРаспознавания(Знач Шаблон) Экспорт
	Токены = ТокеныШаблона("(" + Шаблон + ")");
	Орграф = НовыйОрграф(Токены.Количество() + 1);
	Стек = НовыйСтек();
	ИндексыОператоровИЛИ = Новый Массив;
	М = Токены.ВГраница();
	ЭтоТокенМета = Ложь;
	
	Для я = 0 По М Цикл
		ПозицияЛевойСкобки = я;
		Токен = Токены[я];
		ЭтоТокенМета = ЭтоТокенМетасимвола(Токен);
		Если ЭтоТокенМета Тогда
			Токен = Токен.Значение;
		Если Токен = "(" ИЛИ Токен = "|" Тогда
            ДобавитьВСтек(Стек, я);
		ИначеЕсли Токен = ")" Тогда
			ИндексыОператоровИЛИ.Очистить();
				ПредыдущийТокен = "";
				Пока ПредыдущийТокен <> "(" Цикл
				Если СтекПустой(Стек) Тогда
					ВызватьИсключение "Ошибка разбора шаблона";
				КонецЕсли;
				
	            ПозицияОператора = ИзъятьИзСтека(Стек);
					ПредыдущийТокен = Токены[ПозицияОператора];
					Если НЕ ЭтоТокенМетасимвола(ПредыдущийТокен) Тогда
						ПредыдущийТокен = "";
						Продолжить;
					КонецЕсли;
					ПредыдущийТокен = ПредыдущийТокен.Значение;
					Если ПредыдущийТокен = "|" Тогда
					ИндексыОператоровИЛИ.Добавить(ПозицияОператора);
		            ИначеЕсли ПредыдущийТокен = "(" Тогда
	                ПозицияЛевойСкобки = ПозицияОператора;
					Для Каждого Индекс Из ИндексыОператоровИЛИ Цикл
						ДобавитьНаправлениеВОрграф(Орграф, ПозицияЛевойСкобки, Индекс+1);
						ДобавитьНаправлениеВОрграф(Орграф, Индекс, я);
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли Токен = "]" Тогда
			ПозицияЛевойСкобки = я - 2;
		КонецЕсли;
		КонецЕсли;
		Если я < М Тогда
			СледующийТокен = Токены[я+1];
			Если ЭтоТокенМетасимвола(СледующийТокен) Тогда
				СледующийТокен = СледующийТокен.Значение;
			Если СледующийТокен = "*" Тогда
				ДобавитьНаправлениеВОрграф(Орграф, ПозицияЛевойСкобки, я+1);
				ДобавитьНаправлениеВОрграф(Орграф, я+1, ПозицияЛевойСкобки);
			ИначеЕсли СледующийТокен = "+" Тогда
				ДобавитьНаправлениеВОрграф(Орграф, я+1, ПозицияЛевойСкобки);
			ИначеЕсли СледующийТокен = "?" Тогда
				ДобавитьНаправлениеВОрграф(Орграф, ПозицияЛевойСкобки, я+2);
			КонецЕсли;
        КонецЕсли;
		КонецЕсли;
		Если ЭтоТокенМета Тогда
            ДобавитьНаправлениеВОрграф(Орграф, я, я+1);
		КонецЕсли;
    КонецЦикла;
	
	Возврат Новый Структура("Шаблон, Орграф", Токены, Орграф);
КонецФункции

// Выполняет проверку на полное соответствие текста регулярному выражению
//
// Параметры:
//  Процессор	 - Структура - процессора распознавания
//  Текст		 - Строка	 - текст, который будет проверятся процессором на полное соответствие
// 
// Возвращаемое значение:
//  Булево - успешность проверки
//
Функция Распознано(Знач Процессор, Знач Текст) Экспорт
	ТипСтруктура = Тип("Структура");
	ТипСтрока = Тип("Строка");
	Вершины = ДостижимыеВершины(Процессор);
	Финал = Процессор.Шаблон.Количество();
	
	Для я = 1 По СтрДлина(Текст) Цикл
		Символ = Сред(Текст, я, 1);
		Совпадения = НовыйМешок();
		Для Каждого Вершина Из ЭлементыМешка(Вершины) Цикл
			Если Вершина < Финал Тогда
				Токен = Процессор.Шаблон[Вершина];
				ТипТокена = ТипЗнч(Токен);
				Если ТипТокена = ТипСтруктура Тогда
					Если Токен.Тип = РегВырПовтИсп.ТипТокенаКлассСимволов() И СимволУдовлетворяетКлассу(Символ, Токен) Тогда
						ДобавитьВМешок(Совпадения, Вершина+1);
					КонецЕсли;
				ИначеЕсли ТипТокена = ТипСтрока И Токен = Символ Тогда
					ДобавитьВМешок(Совпадения, Вершина+1);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Вершины = ДостижимыеВершины(Процессор, Совпадения);
	КонецЦикла;
	
	Возврат ДостигнутаФинальнаяВершина(Вершины, Процессор);
КонецФункции

// Возвращает найденные процессором вхождения в тексте
//
// Параметры:
//  Процессор	 - Структура - процессора распознавания
//  Текст		 - Строка	 - текст, в котором будет осуществляться поиск вхождений
// 
// Возвращаемое значение:
//  Массив - найденные вхождения. Элементы - Структура с ключами:
//  * НачальнаяПозиция - Число - позиция первого символа вхождения в тексте,
//  * Длина - Число - количество символов в найденном вхождении,
//  * Значение - Строка - строка вхождения
//
Функция Вхождения(Знач Процессор, Знач Текст) Экспорт
	фРезультат = Новый Массив;
	ТипСтруктура = Тип("Структура");
	ТипСтрока = Тип("Строка");
	Вершины = ДостижимыеВершины(Процессор);
	Финал = Процессор.Шаблон.Количество();
	Начало = 0;
	ЭтоПотенциальноеСовпадение = Ложь;
	
	Для я = 1 По СтрДлина(Текст) Цикл
		Символ = Сред(Текст, я, 1);
		Совпадения = НовыйМешок();
		Для Каждого Вершина Из ЭлементыМешка(Вершины) Цикл
			Если Вершина < Финал Тогда
				Токен = Процессор.Шаблон[Вершина];
				ТипТокена = ТипЗнч(Токен);
				Если ТипТокена = ТипСтруктура Тогда
					Если Токен.Тип = РегВырПовтИсп.ТипТокенаКлассСимволов() И СимволУдовлетворяетКлассу(Символ, Токен) Тогда
						Если Начало = 0 Тогда
							Начало = я;
						КонецЕсли;
						ДобавитьВМешок(Совпадения, Вершина+1);
					КонецЕсли;
				ИначеЕсли ТипТокена = ТипСтрока И Токен = Символ Тогда
					Если Начало = 0 Тогда
						Начало = я;
					КонецЕсли;
					ДобавитьВМешок(Совпадения, Вершина+1);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Если МешокПуст(Совпадения) Тогда
			Если Начало > 0 Тогда
				Если ДостигнутаФинальнаяВершина(Вершины, Процессор) Тогда
					фРезультат.Добавить(НовоеВхождение(Начало, я, Текст));
				КонецЕсли;
				Вершины = ДостижимыеВершины(Процессор);
				я = я - 1;
				Начало = 0;
				ЭтоПотенциальноеСовпадение = Ложь;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		ЕстьФинальнаяВершина = Ложь;
		Вершины = ДостижимыеВершины(Процессор, Совпадения);
		Если ДостигнутаФинальнаяВершина(Вершины, Процессор) Тогда
			ЕстьФинальнаяВершина = Истина;
			ЭтоПотенциальноеСовпадение = Истина;
		КонецЕсли;
		Если ЭтоПотенциальноеСовпадение И НЕ ЕстьФинальнаяВершина Тогда
			фРезультат.Добавить(НовоеВхождение(Начало, я, Текст));
			
			Вершины = ДостижимыеВершины(Процессор);
			я = я - 1;
			Начало = 0;
			ЭтоПотенциальноеСовпадение = Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Если ДостигнутаФинальнаяВершина(Вершины, Процессор) Тогда
		фРезультат.Добавить(НовоеВхождение(Начало, СтрДлина(Текст)+1, Текст));
	КонецЕсли;
	
	Возврат фРезультат;
КонецФункции
#КонецОбласти

#Область СлужебныеПроцедурыИФункции
#Область КОНСТРУКТОРЫ
Функция НовыйСтек()
	Возврат Новый Массив;
КонецФункции

Функция НовыйМешок()
	Возврат Новый Структура("Первая, Хранилище", Неопределено, Новый Соответствие);
КонецФункции

Функция НоваяНода(Знач Значение)
	Возврат Новый Структура("Ссылка, Следующая, Значение", 0, Неопределено, Значение);
КонецФункции

Функция НовыйОрграф(Знач Мощность)
	фРезультат = Новый Массив;
	Для я = 1 По Мощность Цикл
		фРезультат.Добавить(НовыйМешок());
	КонецЦикла;
	
	Возврат фРезультат;
КонецФункции

Функция НовыйНаправленныйПоискВГлубину(Знач Орграф, Знач НомерВершины)
	фРезультат = Новый Массив;
	Для _ = 1 По КоличествоВершинОрграфа(Орграф) Цикл
		фРезультат.Добавить(Ложь);
	КонецЦикла;
	
	ПоискВГлубину(фРезультат, Орграф, НомерВершины);
	
	Возврат фРезультат;
КонецФункции

Функция НовыйНаправленныйПоискВГлубинуПоВершинам(Знач Орграф, Знач Источники)
	фРезультат = Новый Массив;
	Для _ = 1 По КоличествоВершинОрграфа(Орграф) Цикл
		фРезультат.Добавить(Ложь);
	КонецЦикла;
	
	Для Каждого Источник Из ЭлементыМешка(Источники) Цикл
		Если НЕ фРезультат.Получить(Источник) Тогда
			ПоискВГлубину(фРезультат, Орграф, Источник);
		КонецЕсли;
	КонецЦикла;
	
	Возврат фРезультат;
КонецФункции

Функция НовоеВхождение(Знач НачальнаяПозиция, Знач КонечнаяПозиция, Знач Текст)
	Возврат Новый Структура("НачальнаяПозиция, Длина, Значение", НачальнаяПозиция, КонечнаяПозиция - НачальнаяПозиция, Сред(Текст, НачальнаяПозиция, КонечнаяПозиция - НачальнаяПозиция));
КонецФункции
#КонецОбласти

#Область Стек
Процедура ДобавитьВСтек(Стек, Знач Значение)
	Стек.Добавить(Значение);
КонецПроцедуры

Функция ИзъятьИзСтека(Стек)
	Перем фРезультат;
	Если СтекПустой(Стек) Тогда
		Возврат фРезультат;
	КонецЕсли;
	фРезультат = Стек.Получить(Стек.ВГраница());
	Стек.Удалить(Стек.ВГраница());
	Возврат фРезультат;
КонецФункции

Функция ВзятьИзСтека(Знач Стек)
	Перем фРезультат;
	Если СтекПустой(Стек) Тогда
		Возврат фРезультат;
	КонецЕсли;
	
	Возврат Стек.Получить(Стек.ВГраница());
КонецФункции

Функция ЭлементыСтека(Знач Стек)
	фРезультат = Новый Массив;
	
	Если СтекПустой(Стек) Тогда
		Возврат фРезультат;
	КонецЕсли;
	
	я = Стек.ВГраница();
	Пока я >= 0 Цикл
		фРезультат.Добавить(Стек[я]);
		я = я - 1;
	КонецЦикла;
	
	Возврат фРезультат;
КонецФункции

Функция СтекПустой(Знач Стек)
	Возврат Стек.Количество() = 0;
КонецФункции
#КонецОбласти

#Область Мешок
Процедура ДобавитьВМешок(Мешок, Знач Значение)
	НоваяПервая = НоваяНода(Значение);
	ТекущаяПервая = Мешок.Первая;
	Если ТекущаяПервая <> Неопределено Тогда
		ТекущаяПервая = ТекущаяПервая.Ссылка;
		НоваяПервая.Ссылка = ТекущаяПервая + 1;
	КонецЕсли;
	НоваяПервая.Следующая = ТекущаяПервая;
	Мешок.Первая = НоваяПервая;
	Мешок.Хранилище.Вставить(НоваяПервая.Ссылка, НоваяПервая);
КонецПроцедуры

Функция РазмерМешка(Знач Мешок)
	Возврат Мешок.Хранилище.Количество();
КонецФункции

Функция МешокПуст(Знач Мешок)
	Возврат Мешок.Хранилище.Количество() = 0;
КонецФункции

Функция ЭлементыМешка(Знач Мешок)
	фРезультат = Новый Массив;
	
	Текущая = Мешок.Первая;
	Пока Текущая <> Неопределено Цикл
		фРезультат.Добавить(Текущая.Значение);
		Текущая = Мешок.Хранилище.Получить(Текущая.Следующая);
	КонецЦикла;
	
	Возврат фРезультат;
КонецФункции
#КонецОбласти

#Область ОриентированныйГраф
Функция КоличествоВершинОрграфа(Знач Орграф)
	Возврат Орграф.Количество();
КонецФункции

Функция КоличествоНаправленийОрграфа(Знач Орграф)
	фРезультат = 0;
	
	Для Каждого Направления Из Орграф Цикл
		фРезультат = фРезультат + РазмерМешка(Направления);
	КонецЦикла;
	
	Возврат фРезультат;
КонецФункции

Процедура ДобавитьНаправлениеВОрграф(Орграф, Знач НомерВершиныОтправления, Знач НомерВершиныНазначения)
	Направления = Орграф.Получить(НомерВершиныОтправления);
	ДобавитьВМешок(Направления, НомерВершиныНазначения);
КонецПроцедуры

Функция РеверсОрграфа(Знач Орграф)
	фРезультат = НовыйОрграф(КоличествоВершинОрграфа(Орграф));
	
	Для я = 0 По КоличествоВершинОрграфа(Орграф)-1 Цикл
		Для Каждого Направление Из ЭлементыМешка(Орграф.Получить(я)) Цикл
			ДобавитьНаправлениеВОрграф(фРезультат, я, Направление);
		КонецЦикла;
	КонецЦикла;
	
	Возврат фРезультат;
КонецФункции
#КонецОбласти

#Область ПоискВГлубину
Процедура ПоискВГлубину(Знач ОбъектПВГ, Знач Орграф, Знач НомерВершины)
	ОбъектПВГ.Установить(НомерВершины, Истина);
	Для Каждого Направление Из ЭлементыМешка(Орграф.Получить(НомерВершины)) Цикл
		Если НЕ ОбъектПВГ.Получить(Направление) Тогда
			ПоискВГлубину(ОбъектПВГ, Орграф, Направление);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция НайденоПоискомВГлубину(Знач ОбъектПВГ, Знач НомерВершины)
	Возврат ОбъектПВГ.Получить(НомерВершины);
КонецФункции
#КонецОбласти

Функция ДостижимыеВершины(Знач Процессор, Знач Совпадения = Неопределено)
	фРезультат = НовыйМешок();
	
	ОбъектПВГ = ?(
		Совпадения = Неопределено,
		НовыйНаправленныйПоискВГлубину(Процессор.Орграф, 0),
		НовыйНаправленныйПоискВГлубинуПоВершинам(Процессор.Орграф, Совпадения)
	);
	
	Для Вершина = 0 По КоличествоВершинОрграфа(Процессор.Орграф) - 1 Цикл
		Если НайденоПоискомВГлубину(ОбъектПВГ, Вершина) Тогда
			ДобавитьВМешок(фРезультат, Вершина);
		КонецЕсли;
	КонецЦикла;
	
	Возврат фРезультат;
КонецФункции

Функция ДостигнутаФинальнаяВершина(Знач Вершины, Знач Процессор)
	Финал = Процессор.Шаблон.Количество();
	
	Для Каждого Вершина Из ЭлементыМешка(Вершины) Цикл
		Если Вершина = Финал Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
КонецФункции

Функция ТокеныШаблона(Знач Шаблон)
	фРезультат = Новый Массив;
	МетаСимволы = РегуляркаПовтИсп.Метасимволы();
	
	Для я = 1 По СтрДлина(Шаблон) Цикл
		Символ = Сред(Шаблон, я, 1);
		Если Символ = "[" Тогда
			ОбработатьКлассСимволов(фРезультат, я, Шаблон);
		ИначеЕсли Символ = "{" Тогда
			ОбработатьКвантификатор(фРезультат, я, Шаблон);
		ИначеЕсли Символ = "\" Тогда
			ОбработатьЭкранирование(фРезультат, я, Шаблон);
		ИначеЕсли МетаСимволы.Получить(Символ) <> Неопределено Тогда
			фРезультат.Добавить(ТокенМетаСимвола(Символ));
		ИначеЕсли Символ = "." Тогда
			фРезультат.Добавить(НовыйТокенОбъект(РегВырПовтИсп.ТипТокенаКлассСимволов(), НовыеДанныеТокенаКлассаЛюбыхСимволов()));
		Иначе
			фРезультат.Добавить(Символ);
		КонецЕсли;
	КонецЦикла;
	
	Возврат фРезультат;
КонецФункции

Процедура ОбработатьКлассСимволов(Токены, Индекс, Знач Шаблон)
	Отрицание = Ложь;
	СимволыКласса = Новый Массив;
	ПозицииСимволов = Новый Массив;
	
	Индекс = Индекс + 1;
	СледующийСимвол = Сред(Шаблон, Индекс, 1);
	Если СледующийСимвол = "^" Тогда
		Отрицание = Истина;
		Индекс = Индекс + 1;
		СледующийСимвол = Сред(Шаблон, Индекс, 1);
	КонецЕсли;
	Экранирован = Ложь;
	Пока СледующийСимвол <> "]" ИЛИ Экранирован Цикл
		Экранирован = (СледующийСимвол = "\");
		СимволыКласса.Добавить(СледующийСимвол);
		Индекс = Индекс + 1;
		СледующийСимвол = Сред(Шаблон, Индекс, 1);
	КонецЦикла;
	
	М = СимволыКласса.ВГраница();
	Диапазоны = Новый Массив;
	
	Для я = 0 По М Цикл
		Если СимволыКласса[я] = "\" Тогда
			я = я + 1;
			
			ОбработатьЭкранированныйСимволКласса(СимволыКласса, я);
		ИначеЕсли СимволыКласса[я] = "-" И 0 < я И я < М Тогда
			СимволНачала = СимволыКласса[я-1];
			СимволОкончания = СимволыКласса[я+1];
			Если СимволОкончания = "\" Тогда
				я = я + 2;
				
				ОбработатьЭкранированныйСимволКласса(СимволыКласса, я);
				
				СимволОкончания = СимволыКласса[я];
			Иначе
				я = я + 1;
			КонецЕсли;
			ДобавитьДиапазон(Диапазоны, СимволНачала, СимволОкончания);
			ПозицииСимволов.Удалить(ПозицииСимволов.ВГраница());
			Продолжить;
		КонецЕсли;
		
	    ПозицииСимволов.Добавить(я);
	КонецЦикла;
	
	Токен = НовыйТокенОбъект(РегВырПовтИсп.ТипТокенаКлассСимволов(), НовыеДанныеТокенаКлассаСимволов(Отрицание));
	Для Каждого я Из ПозицииСимволов Цикл
		ДобавитьВТокенКлассаСимволов(Токен, СимволыКласса[я]);
	КонецЦикла;
	Если Диапазоны.Количество() > 0 Тогда
		ДобавитьВТокенКлассаСимволов(Токен, "Диапазоны", Диапазоны);
	КонецЕсли;
	
	Токены.Добавить(ТокенМетаСимвола("["));
	Токены.Добавить(Токен);
	Токены.Добавить(ТокенМетаСимвола("]"));
КонецПроцедуры

Функция НовыйТокенОбъект(Знач Тип, Знач Данные = Неопределено)
	Возврат Новый Структура("Тип, Данные", Тип, Данные);
КонецФункции

Функция НовыеДанныеТокенаКлассаСимволов(Знач Отрицание = Ложь)
	Возврат Новый Структура("Отрицание, Класс", Отрицание, Новый Соответствие);
КонецФункции

Функция НовыеДанныеТокенаКлассаЛюбыхСимволов()
	Возврат Новый Структура("Отрицание, Класс", Ложь, Неопределено);
КонецФункции

Процедура ДобавитьДиапазон(Диапазоны, Знач ЛевыйСимвол, Знач ПравыйСимвол)
	Диапазоны.Добавить(Новый Структура("Начало, Окончание", КодСимвола(ЛевыйСимвол), КодСимвола(ПравыйСимвол)));
КонецПроцедуры

Процедура ДобавитьВТокенКлассаСимволов(Токен, Знач Ключ, Знач Значение = Истина)
	Токен.Данные.Класс.Вставить(Ключ, Значение);
КонецПроцедуры

Функция ТокенМетаСимвола(Знач Значение)
	Возврат Новый Структура("Тип, Значение", РегВырПовтИсп.ТипТокенаМетасимвол(), Значение);
КонецФункции

Функция ЭтоТокенМетасимвола(Знач Токен)
	Возврат ТипЗнч(Токен) = Тип("Структура") И Токен.Тип = РегуляркаПовтИсп.ТипТокенаМетасимвол();
КонецФункции

Функция СимволУдовлетворяетКлассу(Знач Символ, Знач Токен)
	Принадлежит = СимволПринадлежитКлассу(Символ, Токен);
	
	Возврат ?(Токен.Данные.Отрицание, НЕ Принадлежит, Принадлежит);
КонецФункции

Функция СимволПринадлежитКлассу(Знач Символ, Знач Токен)
	Если Токен.Данные.Класс = Неопределено Тогда // .
		Возврат Истина;
	КонецЕсли;
	
	Если Токен.Данные.Класс.Получить(Символ) <> Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	Диапазоны = Токен.Данные.Класс.Получить("Диапазоны");
	Если Диапазоны = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Код = КодСимвола(Символ);
	Для Каждого Диапазон Из Диапазоны Цикл
		Если Диапазон.Начало <= Код И Код <= Диапазон.Окончание Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
КонецФункции

Процедура ОбработатьЭкранированныйСимволКласса(СимволыКласса, Индекс)
	Если СимволыКласса[Индекс] = "x" Тогда // 0xhh
		Символ = СимволПоДвузначномуHexКоду(СимволыКласса[Индекс+1] + СимволыКласса[Индекс+2]);
		Индекс = Индекс + 2;
	ИначеЕсли СимволыКласса[Индекс] = "u" Тогда // 0xhhhh
		Символ = СимволПоЧетырехзначномуHexКоду(СимволыКласса[Индекс+1] + СимволыКласса[Индекс+2] + СимволыКласса[Индекс+3] + СимволыКласса[Индекс+4]);
		Индекс = Индекс + 4;
	Иначе
		Символ = РегВырПовтИсп.ЭкранированияСимволовВКлассе().Получить(СимволыКласса[Индекс]);
		Если Символ = Неопределено Тогда
			ВызватьИсключение "неподдерживаемый ключ экранирования: " + Символ;
		КонецЕсли;
	КонецЕсли;
		
	СимволыКласса[Индекс] = Символ;
КонецПроцедуры

Процедура ОбработатьКвантификатор(Токены, Индекс, Знач Шаблон)
	СимволыКвантификатора = Новый Массив;
	Индекс = Индекс + 1;
	СледующийСимвол = Сред(Шаблон, Индекс, 1);
	Пока СледующийСимвол <> "}" Цикл
		СимволыКвантификатора.Добавить(СледующийСимвол);
		Индекс = Индекс + 1;
		СледующийСимвол = Сред(Шаблон, Индекс, 1);
	КонецЦикла;
	
	ЧастиКвантификатора = СтрРазделить(СтрСоединить(СимволыКвантификатора), ",");
	Если ЧастиКвантификатора.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ДополнительныеТокены = Новый Массив;
	ТипЧисло = Новый ОписаниеТипов("Число");
	МинимумПовторений = ТипЧисло.ПривестиЗначение(СокрЛП(ЧастиКвантификатора[0]));
	МаксимумПовторений = МинимумПовторений;
	Если ЧастиКвантификатора.Количество() > 1 Тогда
		МаксимумПовторений = ТипЧисло.ПривестиЗначение(СокрЛП(ЧастиКвантификатора[1]));
	КонецЕсли;
	Если МаксимумПовторений > 0 И МаксимумПовторений < МинимумПовторений Тогда
		ВызватьИсключение "Ошибка разбора шаблона";
	ИначеЕсли МинимумПовторений = 0 Тогда
		Если МаксимумПовторений < 2 Тогда
			Токены.Добавить(ТокенМетаСимвола(?(МаксимумПовторений = 0, "*", "?")));
			Возврат;
		КонецЕсли;
		ДополнительныеТокены.Добавить(ТокенМетаСимвола("?"));
		МаксимумПовторений = МаксимумПовторений - 1;
	ИначеЕсли МинимумПовторений = 1 И МаксимумПовторений = 0 Тогда
		Токены.Добавить(ТокенМетаСимвола("+"));
		Возврат;
	КонецЕсли;
	
	ТокеныПовторения = Новый Массив;
	ПредыдущийТокен = Токены[Токены.ВГраница()];
	Если ЭтоТокенМетасимвола(ПредыдущийТокен) Тогда
		Если ПредыдущийТокен.Значение = "]" Тогда
			ТокеныПовторения.Добавить(ТокенМетаСимвола("["));
		ТокеныПовторения.Добавить(Токены[Токены.ВГраница()-1]);
			ТокеныПовторения.Добавить(ТокенМетаСимвола("]"));
		ИначеЕсли ПредыдущийТокен.Значение = ")" Тогда
		Стек = НовыйСтек();
		я = Токены.ВГраница();
		Пока я >= 0 Цикл
			Токен = Токены[я];
			ДобавитьВСтек(Стек, Токен);
				Если ЭтоТокенМетасимвола(Токен) И Токен.Значение = "(" Тогда
				Прервать;
			КонецЕсли;
			я = я - 1;
		КонецЦикла;
		ТокеныПовторения = ЭлементыСтека(Стек);
		КонецЕсли;
	Иначе
		ТокеныПовторения.Добавить(ПредыдущийТокен);
	КонецЕсли;
	
	Для Каждого Токен Из ДополнительныеТокены Цикл
		Токены.Добавить(Токен);
	КонецЦикла;
	
	Для я = 1 По МинимумПовторений - 1 Цикл
		Для Каждого Токен Из ТокеныПовторения Цикл
			Токены.Добавить(Токен);
		КонецЦикла;
	КонецЦикла;
	Если МаксимумПовторений = 0 Тогда
		Токены.Добавить(ТокенМетаСимвола("+"));
		Возврат;
	КонецЕсли;
	Для я = 1 По МаксимумПовторений - МинимумПовторений Цикл
		Для Каждого Токен Из ТокеныПовторения Цикл
			Токены.Добавить(Токен);
		КонецЦикла;
		Токены.Добавить(ТокенМетаСимвола("?"));
	КонецЦикла;
КонецПроцедуры

Процедура ОбработатьЭкранирование(Токены, Индекс, Знач Шаблон)
	Индекс = Индекс + 1;
	СледующийСимвол = Сред(Шаблон, Индекс, 1);
	
	Символ = РегВырПовтИсп.ЭкранированияСимволов().Получить(СледующийСимвол);
	Если Символ <> Неопределено Тогда
		Токены.Добавить(Символ);
		Возврат;
	КонецЕсли;
	
	ТокеныКласса = РегВырПовтИсп.ПредопределенныеКлассыСимволов().Получить(СледующийСимвол);
	Если ТокеныКласса <> Неопределено Тогда
		Для Каждого Токен Из ТокеныКласса Цикл
			Токены.Добавить(Токен);
		КонецЦикла;
		Возврат;
	КонецЕсли;
	
	Если СледующийСимвол = "x" Тогда // 0xhh
		Токены.Добавить(СимволПоДвузначномуHexКоду(Шаблон, Индекс));
		Индекс = Индекс + 2;
		Возврат;
	КонецЕсли;
	
	Если СледующийСимвол = "u" Тогда // 0xhhhh
		Токены.Добавить(СимволПоЧетырехзначномуHexКоду(Шаблон, Индекс));
		Индекс = Индекс + 4;
		Возврат;
	КонецЕсли;
	
	ВызватьИсключение "неподдерживаемый ключ экранирования: " + СледующийСимвол;
КонецПроцедуры

Функция СимволПоДвузначномуHexКоду(Знач Шаблон, Знач Индекс = 0)
	фРезультат = Новый Массив;
	фРезультат.Добавить(Сред(Шаблон, Индекс+1, 1));
	фРезультат.Добавить(Сред(Шаблон, Индекс+2, 1));
	
	Возврат Символ(ШвД(СтрСоединить(фРезультат)));
КонецФункции

Функция СимволПоЧетырехзначномуHexКоду(Знач Шаблон, Знач Индекс = 0)
	фРезультат = Новый Массив;
	фРезультат.Добавить(Сред(Шаблон, Индекс+1, 1));
	фРезультат.Добавить(Сред(Шаблон, Индекс+2, 1));
	фРезультат.Добавить(Сред(Шаблон, Индекс+3, 1));
	фРезультат.Добавить(Сред(Шаблон, Индекс+4, 1));
	
	Возврат Символ(ШвД(СтрСоединить(фРезультат)));
КонецФункции

Функция ШвД(Знач ЧислоHex)
	фРезультат = 0;
	
	ЧислоHex = ВРег(СокрЛП(ЧислоHex));
	Степень = СтрДлина(ЧислоHex) - 1;
	ЗначенияDec = РегВырПовтИсп.ЗначенияЦифрHexВDec();
	
	Для я = 1 По СтрДлина(ЧислоHex) Цикл
		ЗначениеDec = ЗначенияDec.Получить(Сред(ЧислоHex, я, 1));
		Если ЗначениеDec = Неопределено Тогда
			ВызватьИсключение "неожиданный символ hex: " + Сред(ЧислоHex, 1, 1);
		КонецЕсли;
		Если ЗначениеDec > 0 Тогда
	    	фРезультат = фРезультат + ЗначениеDec * Pow(16, Степень);
		КонецЕсли;
		Степень = Степень - 1;
	КонецЦикла;
	
	Возврат фРезультат;
КонецФункции
#КонецОбласти
